<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Pixel Planet</title>
    <!-- Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://www.googletagmanager.com https://www.google-analytics.com; style-src 'self' 'unsafe-inline';">
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-E7M919FPNB"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        if (!window.gaInitialized) {
            gtag('config', 'G-E7M919FPNB');
            window.gaInitialized = true;
        }
    </script>
    <style>
        /* CSS Variables for Theming */
        :root {
            --background-color: #f0f0f0;
            --text-color: #333;
            --button-bg-color: #008CBA;
            --button-text-color: #fff;
            --modal-bg-color: rgba(0, 0, 0, 0.5);
            --modal-content-bg: #fff;
            --upgrade-bg-color: #e0e0e0;
        }

        body.dark-theme {
            --background-color: #121212;
            --text-color: #e0e0e0;
            --button-bg-color: #1f8ef1;
            --modal-content-bg: #1e1e1e;
            --upgrade-bg-color: #2c2c2c;
        }

        body.light-theme {
            --background-color: #ffffff;
            --text-color: #000000;
            --button-bg-color: #008CBA;
            --modal-content-bg: #ffffff;
            --upgrade-bg-color: #e0e0e0;
        }

        /* Global Styles */
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
        }

        /* Credits */
        #credits {
            position: fixed;
            bottom: 10px;
            left: 10px;
            font-size: 0.9em;
            color: var(--text-color);
        }

        #credits a {
            color: var(--button-bg-color);
            text-decoration: none;
        }

        /* Version Number */
        #version {
            position: fixed;
            bottom: 10px;
            right: 10px;
            font-size: 0.9em;
            color: var(--text-color);
        }

        /* Buttons */
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 1em;
            border: none;
            border-radius: 5px;
            background-color: var(--button-bg-color);
            color: var(--button-text-color);
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover:not(:disabled) {
            background-color: #005f6a;
        }

        button:disabled {
            background-color: #888;
            cursor: not-allowed;
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 1005; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: var(--modal-bg-color); 
            animation: fadeIn 0.5s;
        }

        .modal-content {
            background-color: var(--modal-content-bg);
            margin: 5% auto; 
            padding: 20px;
            border: 1px solid #888;
            width: 90%; 
            max-width: 700px;
            border-radius: 10px;
            color: var(--text-color);
            text-align: left;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            animation: slideIn 0.5s;
        }

        .close-modal {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-modal:hover,
        .close-modal:focus {
            color: #000;
            text-decoration: none;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .upgrade, .achievement, .event, .biome, .quest {
                width: 45%;
            }
        }

        @media (max-width: 768px) {
            .upgrade, .achievement, .event, .biome, .quest {
                width: 70%;
            }
        }

        @media (max-width: 480px) {
            button {
                width: 80%;
                font-size: 1em;
            }

            .upgrade, .achievement, .event, .biome, .quest {
                width: 90%;
            }

            #leaderboard-table th, #leaderboard-table td {
                font-size: 0.8em;
                padding: 6px;
            }

            .social-buttons {
                flex-direction: column;
            }

            .social-button {
                width: 100%;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        /* Tooltip */
        .tooltip {
            visibility: hidden;
            width: 160px;
            background-color: var(--upgrade-bg-color);
            color: var(--text-color);
            text-align: center;
            border-radius: 6px;
            padding: 5px 0;
            position: absolute;
            z-index: 1;
            bottom: 125%; /* Position above the button */
            left: 50%;
            margin-left: -80px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .upgrade-button:hover .tooltip,
        .upgrade-button:focus .tooltip {
            visibility: visible;
            opacity: 1;
        }

        /* Leaderboard Styles */
        #leaderboard {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #leaderboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        #leaderboard-table th, #leaderboard-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        #leaderboard-table th {
            background-color: var(--upgrade-bg-color);
        }

        /* Social Sharing Buttons */
        .social-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .social-button {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Main Menu Styles */
        #main-menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            text-align: center;
            padding: 20px;
        }

        #main-menu h1 {
            font-size: 3em;
            margin-bottom: 20px;
        }

        #language-selector {
            margin-top: 20px;
        }

        /* Game Interface Styles */
        #game {
            display: none;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        #resources {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .resource {
            background-color: var(--upgrade-bg-color);
            padding: 10px;
            border-radius: 5px;
            width: 200px;
            margin: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* Sections */
        .section {
            margin-bottom: 30px;
        }

        .section h3 {
            margin-bottom: 10px;
        }

        /* Control Buttons */
        .control-buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Notification Styles */
        #notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: var(--upgrade-bg-color);
            color: var(--text-color);
            padding: 10px 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
            display: none;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 1006;
        }

        /* Accessibility Enhancements */
        button:focus {
            outline: 2px solid #555;
        }

    </style>
</head>
<body>
    <!-- Credits -->
    <div id="credits">
        Made By <a href="https://sites.google.com/view/staticquasar931/static-gmes/pixel-planet" target="_blank" rel="noopener noreferrer">Static</a>
    </div>

    <!-- Version Number -->
    <div id="version">
        Version 0.6
    </div>

    <!-- Help Button -->
    <button id="help-button" onclick="openHelp()" aria-label="Open Help Modal">‚ùì Help</button>

    <!-- Share Button -->
    <button id="share-button" onclick="shareGame()" aria-label="Share Game">üì§ Share</button>

    <!-- Tutorial Modal -->
    <div id="tutorial-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="tutorial-modal-title">
        <div class="modal-content">
            <span class="close-modal" onclick="closeTutorial()" aria-label="Close Tutorial Modal">&times;</span>
            <h2 id="tutorial-modal-title">üìñ Pixel Planet Tutorial</h2>
            <p>Welcome to Pixel Planet! Let's walk you through the basics:</p>
            <ol>
                <li><strong>Start New Game:</strong> Click the "Start New Game" button to begin your adventure.</li>
                <li><strong>Generate Resources:</strong> Click "Generate Resources" to manually collect resources. Resources also accumulate automatically over time.</li>
                <li><strong>Upgrades:</strong> Visit the "Upgrades" section to purchase improvements that enhance your resource generation and efficiency. Some upgrades automate resource collection, allowing you to focus on other tasks.</li>
                <li><strong>Biomes:</strong> Unlock new biomes by terraforming your planet. Each biome provides unique resource bonuses.</li>
                <li><strong>Achievements:</strong> Achieve milestones to unlock rewards and showcase your progress.</li>
                <li><strong>Quests:</strong> Complete daily and weekly quests to earn additional rewards and keep your gameplay engaging.</li>
                <li><strong>Leaderboard:</strong> Enter your name and see how you rank against other players based on your total resources.</li>
                <li><strong>Localization:</strong> Choose your preferred language from the language selector to enjoy the game in your native language.</li>
                <li><strong>Social Sharing:</strong> Share your achievements and progress on social media to invite friends and challenge them.</li>
                <li><strong>Accessibility:</strong> Navigate the game using your keyboard and enjoy improved accessibility features designed for all players.</li>
            </ol>
            <p>Explore, strategize, and build your Pixel Planet into a thriving world! üåçüöÄ</p>
            <button onclick="closeTutorial()" aria-label="Close Tutorial">Got It!</button>
        </div>
    </div>

    <!-- Leaderboard Section -->
    <div id="leaderboard" role="dialog" aria-modal="true" aria-labelledby="leaderboard-title">
        <div class="modal-content">
            <span class="close-modal" onclick="closeLeaderboard()" aria-label="Close Leaderboard">&times;</span>
            <h3 id="leaderboard-title">üèÖ Leaderboard</h3>
            <table id="leaderboard-table">
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Player</th>
                        <th>Total Resources</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Leaderboard entries will be dynamically generated -->
                </tbody>
            </table>
            <button id="leaderboard-close" onclick="closeLeaderboard()" aria-label="Close Leaderboard">Close Leaderboard</button>
        </div>
    </div>

    <!-- Social Sharing Buttons -->
    <div class="social-buttons">
        <a href="#" id="share-twitter" target="_blank" aria-label="Share on Twitter">
            <button class="social-button">üê¶ Twitter</button>
        </a>
        <a href="#" id="share-facebook" target="_blank" aria-label="Share on Facebook">
            <button class="social-button">üìò Facebook</button>
        </a>
        <a href="#" id="share-reddit" target="_blank" aria-label="Share on Reddit">
            <button class="social-button">üëΩ Reddit</button>
        </a>
    </div>

    <!-- Main Menu -->
    <div id="main-menu">
        <h1>üåç Pixel Planet</h1>
        <button onclick="startNewGame()" aria-label="Start New Game">üöÄ Start New Game</button>
        <button onclick="continueGame()" id="continue-button" aria-label="Continue Game" style="display: none;">üîÑ Continue Game</button>
        <button onclick="showLeaderboard()" aria-label="Show Leaderboard">üèÖ Leaderboard</button>
        <div id="language-selector">
            <label for="language">üåê Language: </label>
            <select id="language" onchange="changeLanguage(this.value)" aria-label="Language Selector">
                <option value="en">English</option>
                <option value="es">Espa√±ol</option>
                <!-- Add more languages as needed -->
            </select>
        </div>
    </div>

    <!-- Game Interface -->
    <div id="game">
        <h2>Your Planet</h2>
        <div id="resources">
            <div class="resource" id="water">üíß Water: 0 / 1K (Per Second: <span id="water-rate">1.0</span>)</div>
            <div class="resource" id="minerals">‚õè Minerals: 0 / 500 (Per Second: <span id="minerals-rate">0.0</span>)</div>
            <div class="resource" id="plants">üå± Plants: 0 / 300 (Per Second: <span id="plants-rate">0.0</span>)</div>
            <div class="resource" id="energy">‚ö° Energy: 0 / 200 (Per Second: <span id="energy-rate">0.0</span>)</div>
        </div>
        <button onclick="generateResources()" aria-label="Generate Resources">üîÑ Generate Resources</button>

        <!-- Biomes Section -->
        <div id="biomes-section" class="section">
            <h3>üåø Biomes</h3>
            <div id="biomes">
                <!-- Biomes will be dynamically generated -->
            </div>
        </div>

        <!-- Upgrades Section -->
        <div id="upgrades-section" class="section">
            <h3>üíº Upgrades</h3>
            <div id="upgrades">
                <!-- Upgrades will be dynamically generated -->
            </div>
        </div>

        <!-- Achievements Section -->
        <div id="achievements-section" class="section">
            <h3>üèÜ Achievements</h3>
            <div id="achievements">
                <!-- Achievements will be dynamically generated -->
            </div>
        </div>

        <!-- Events Section -->
        <div id="events-section" class="section">
            <h3>üéâ Events</h3>
            <div id="events">
                <!-- Events will be dynamically generated -->
            </div>
        </div>

        <!-- Quests Section -->
        <div id="quests-section" class="section">
            <h3>üéØ Quests</h3>
            <div id="quests">
                <!-- Quests will be dynamically generated -->
            </div>
        </div>

        <!-- Story Section -->
        <div id="story-section" class="section">
            <h3>üìñ Story</h3>
            <div id="story">
                <!-- Story milestones will be dynamically generated -->
            </div>
        </div>

        <!-- Control Buttons -->
        <div class="control-buttons">
            <button onclick="saveGame()" aria-label="Save Game">üíæ Save Game</button>
            <button onclick="unlockTerraform()" aria-label="Terraform Planet">üåç Terraform Planet</button>
            <button onclick="resetGame()" id="reset-button" aria-label="Reset Game">üóëÔ∏è Reset Game</button>
            <button onclick="toggleTheme()" aria-label="Toggle Theme">üé® Toggle Theme</button>
        </div>

        <!-- Social Sharing Buttons (Game) -->
        <div class="social-buttons">
            <a href="#" id="share-twitter-game" target="_blank" aria-label="Share on Twitter">
                <button class="social-button">üê¶ Twitter</button>
            </a>
            <a href="#" id="share-facebook-game" target="_blank" aria-label="Share on Facebook">
                <button class="social-button">üìò Facebook</button>
            </a>
            <a href="#" id="share-reddit-game" target="_blank" aria-label="Share on Reddit">
                <button class="social-button">üëΩ Reddit</button>
            </a>
        </div>
    </div>

    <!-- Feedback Modal -->
    <div id="feedback-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="feedback-modal-title">
        <div class="modal-content">
            <span class="close-modal" onclick="closeFeedback()" aria-label="Close Feedback Modal">&times;</span>
            <h2 id="feedback-modal-title">üìù Feedback</h2>
            <form id="feedback-form">
                <label for="feedback">Your Feedback:</label>
                <textarea id="feedback" name="feedback" rows="4" cols="50" required></textarea>
                <button type="submit" aria-label="Submit Feedback">Submit</button>
            </form>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification"></div>

    <!-- Leaderboard Script -->
    <script>
        // Utility function to format numbers
        function formatNumber(num) {
            if (num >= 1e9) {
                return (num / 1e9).toFixed(1) + 'B';
            } else if (num >= 1e6) {
                return (num / 1e6).toFixed(1) + 'M';
            } else if (num >= 1e3) {
                return (num / 1e3).toFixed(1) + 'K';
            } else {
                return num.toFixed(0);
            }
        }

        // Function to show notifications with queuing to prevent overlap
        let notificationQueue = [];
        let isNotificationVisible = false;

        function showNotification(messageKey, params = []) {
            notificationQueue.push({ messageKey, params });
            if (!isNotificationVisible) {
                displayNextNotification();
            }
        }

        function displayNextNotification() {
            if (notificationQueue.length === 0) {
                isNotificationVisible = false;
                return;
            }
            isNotificationVisible = true;
            const { messageKey, params } = notificationQueue.shift();
            const notification = document.getElementById('notification');
            let message = translations[currentLanguage][messageKey] || notificationMessages[currentLanguage][messageKey] || messageKey;

            // Replace placeholders with actual parameters
            params.forEach((param, index) => {
                message = message.replace(`{${index}}`, param);
            });

            notification.innerText = message;
            notification.style.display = 'block';
            notification.style.opacity = '1';
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => {
                    notification.style.display = 'none';
                    displayNextNotification();
                }, 500);
            }, 3000);
        }

        // Function to update social sharing URLs
        function updateSocialSharing() {
            const currentPlayer = {
                name: sanitizeInput(localStorage.getItem('PixelPlanetPlayerName')) || 'Player',
                totalResources: calculateTotalResources()
            };
            const shareText = encodeURIComponent(`I'm playing Pixel Planet! My total resources: ${formatNumber(currentPlayer.totalResources)}. Check it out: https://sites.google.com/view/staticquasar931/static-gmes/pixel-planet`);
            const twitterURL = `https://twitter.com/intent/tweet?text=${shareText}`;
            const facebookURL = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent('https://sites.google.com/view/staticquasar931/static-gmes/pixel-planet')}`;
            const redditURL = `https://www.reddit.com/submit?url=${encodeURIComponent('https://sites.google.com/view/staticquasar931/static-gmes/pixel-planet')}&title=${shareText}`;

            document.getElementById('share-twitter').href = twitterURL;
            document.getElementById('share-facebook').href = facebookURL;
            document.getElementById('share-reddit').href = redditURL;

            document.getElementById('share-twitter-game').href = twitterURL;
            document.getElementById('share-facebook-game').href = facebookURL;
            document.getElementById('share-reddit-game').href = redditURL;
        }

        // Leaderboard Functions
        function showLeaderboard() {
            updateLeaderboard();
            openModal('leaderboard');
        }

        function closeLeaderboard() {
            closeModal('leaderboard');
        }

        function updateLeaderboard() {
            const leaderboardBody = document.querySelector('#leaderboard-table tbody');
            leaderboardBody.innerHTML = ''; // Clear existing entries

            // Retrieve leaderboard data from localStorage
            let leaderboard = JSON.parse(localStorage.getItem('PixelPlanetLeaderboard')) || [];

            // Current player data
            const currentPlayer = {
                name: sanitizeInput(localStorage.getItem('PixelPlanetPlayerName')) || 'Player',
                totalResources: calculateTotalResources()
            };

            // Add current player to leaderboard if not already present
            if (!leaderboard.some(player => player.name === currentPlayer.name)) {
                leaderboard.push(currentPlayer);
            } else {
                // Update totalResources if player already exists
                leaderboard = leaderboard.map(player => {
                    if (player.name === currentPlayer.name) {
                        return currentPlayer;
                    }
                    return player;
                });
            }

            // Sort leaderboard by totalResources descending
            leaderboard.sort((a, b) => b.totalResources - a.totalResources);

            // Keep top 10
            leaderboard = leaderboard.slice(0, 10);

            // Save updated leaderboard
            localStorage.setItem('PixelPlanetLeaderboard', JSON.stringify(leaderboard));

            // Populate leaderboard table
            leaderboard.forEach((player, index) => {
                const row = document.createElement('tr');

                const rankCell = document.createElement('td');
                rankCell.innerText = index + 1;
                row.appendChild(rankCell);

                const nameCell = document.createElement('td');
                nameCell.innerText = player.name;
                row.appendChild(nameCell);

                const resourcesCell = document.createElement('td');
                resourcesCell.innerText = formatNumber(player.totalResources);
                row.appendChild(resourcesCell);

                leaderboardBody.appendChild(row);
            });
        }

        // Notification Messages
        const notificationMessages = {
            en: {
                "ResourceGenerated": "üîÑ Resources generated!",
                "AchievementUnlocked": "üèÜ Achievement Unlocked: {0} - Reward: {1}",
                "QuestCompleted": "üéØ Quest Completed: {0} - Reward: {1}",
                "GameSaved": "üíæ Game saved!",
                "SaveError": "‚ö†Ô∏è Error saving game.",
                "LoadError": "‚ö†Ô∏è Error loading game. Starting a new game.",
                "UpgradePurchased": "üîß Upgrade Purchased: {0} - {1}",
                "UpgradePurchaseFailed": "‚ùå Not enough Water to purchase this upgrade!",
                "TerraformSuccess": "üåç Planet terraformed! New biome unlocked.",
                "TerraformFailed": "‚ùå Not enough Water to terraform the planet!",
                "ShareReward": "üéÅ Thanks for sharing! Energy +10.",
                "SolarFlareImpact": "‚ö° Solar Flare! Energy production decreased.",
                "SolarFlareRestored": "‚ö° Energy production restored after Solar Flare.",
                "MeteorShowerImpact": "‚õè Meteor Shower! Mineral production increased.",
                "MeteorShowerNormalized": "‚õè Mineral production normalized after Meteor Shower.",
                "EventTriggered": "üéâ Event: {0} - {1}",
                "NewGameStarted": "üöÄ New game started! Welcome to Pixel Planet.",
                "NoSavedGame": "‚ùå No saved game found.",
                "ThemeChanged": "üñåÔ∏è Theme changed to {0}.",
                "VersionMismatch": "üîÑ Game version mismatch. Starting a new game.",
                "GameReset": "üóëÔ∏è Game has been reset.",
                "OfflineResources": "‚è∞ You were offline for {0} seconds. Resources have been updated.",
                "InsufficientResources": "‚ùå Not enough {0} to purchase this upgrade!",
                "LanguageUnsupported": "‚ö†Ô∏è The selected language '{0}' is unsupported. Defaulting to English.",
                "InvalidPlayerName": "‚ùå Invalid name entered. Using default name 'Player'.",
                "AllBiomesUnlocked": "üåü Congratulations! You've unlocked all available biomes!",
                "AlienEncounterReward": "üëΩ Alien technology received! Energy +100.",
                "ResourcePlundered": "üö® Pirates plundered your resources! Water -50, Minerals -30.",
                "FeedbackSubmitted": "‚úÖ Thank you for your feedback!"
            },
            es: {
                "ResourceGenerated": "üîÑ ¬°Recursos generados!",
                "AchievementUnlocked": "üèÜ Logro Desbloqueado: {0} - Recompensa: {1}",
                "QuestCompleted": "üéØ Misi√≥n Completada: {0} - Recompensa: {1}",
                "GameSaved": "üíæ ¬°Juego guardado!",
                "SaveError": "‚ö†Ô∏è Error al guardar el juego.",
                "LoadError": "‚ö†Ô∏è Error al cargar el juego. Iniciando un nuevo juego.",
                "UpgradePurchased": "üîß Actualizaci√≥n Comprada: {0} - {1}",
                "UpgradePurchaseFailed": "‚ùå ¬°No tienes suficiente Agua para comprar esta actualizaci√≥n!",
                "TerraformSuccess": "üåç ¬°Planeta terraformado! Nuevo bioma desbloqueado.",
                "TerraformFailed": "‚ùå ¬°No tienes suficiente Agua para terraformar el planeta!",
                "ShareReward": "üéÅ ¬°Gracias por compartir! Energ√≠a +10.",
                "SolarFlareImpact": "‚ö° ¬°Explosi√≥n Solar! La producci√≥n de energ√≠a disminuy√≥.",
                "SolarFlareRestored": "‚ö° La producci√≥n de energ√≠a se restaur√≥ despu√©s de la Explosi√≥n Solar.",
                "MeteorShowerImpact": "‚õè ¬°Lluvia de Meteoros! La producci√≥n de minerales aument√≥.",
                "MeteorShowerNormalized": "‚õè La producci√≥n de minerales se normaliz√≥ despu√©s de la Lluvia de Meteoros.",
                "EventTriggered": "üéâ Evento: {0} - {1}",
                "NewGameStarted": "üöÄ ¬°Nuevo juego iniciado! Bienvenido a Pixel Planet.",
                "NoSavedGame": "‚ùå No se encontr√≥ un juego guardado.",
                "ThemeChanged": "üñåÔ∏è Tema cambiado a {0}.",
                "VersionMismatch": "üîÑ Incompatibilidad de versi√≥n del juego. Iniciando un nuevo juego.",
                "GameReset": "üóëÔ∏è El juego ha sido reiniciado.",
                "OfflineResources": "‚è∞ Estuviste desconectado por {0} segundos. Los recursos se han actualizado.",
                "InsufficientResources": "‚ùå ¬°No tienes suficiente {0} para comprar esta actualizaci√≥n!",
                "LanguageUnsupported": "‚ö†Ô∏è El idioma seleccionado '{0}' no est√° soportado. Se usa Ingl√©s por defecto.",
                "InvalidPlayerName": "‚ùå Nombre inv√°lido ingresado. Usando el nombre predeterminado 'Player'.",
                "AllBiomesUnlocked": "üåü ¬°Felicidades! ¬°Has desbloqueado todos los biomas disponibles!",
                "AlienEncounterReward": "üëΩ ¬°Tecnolog√≠a alien√≠gena recibida! Energ√≠a +100.",
                "ResourcePlundered": "üö® ¬°Piratas saquearon tus recursos! Agua -50, Minerales -30.",
                "FeedbackSubmitted": "‚úÖ ¬°Gracias por tus comentarios!"
            }
            // Add more languages as needed
        };

        let currentLanguage = 'en';

        function changeLanguage(lang) {
            if (!translations.hasOwnProperty(lang)) {
                showNotification("LanguageUnsupported", [lang]);
                lang = 'en';
            }
            currentLanguage = lang;
            localStorage.setItem('PixelPlanetLanguage', lang);
            applyTranslations();
            updateDynamicContentLanguage();
        }

        function applyTranslations() {
            // Translate button texts and labels
            document.querySelectorAll('button').forEach(button => {
                const key = button.getAttribute('aria-label').replace(/-/g, ' ').trim();
                if (translations[currentLanguage][key]) {
                    // Avoid changing the text of modals and tooltips
                    if (!button.classList.contains('social-button') && !button.classList.contains('close-modal')) {
                        button.innerText = translations[currentLanguage][key];
                    }
                }
            });

            // Translate labels
            document.querySelectorAll('label').forEach(label => {
                const key = label.innerText.replace(':', '').trim();
                if (translations[currentLanguage][key]) {
                    label.innerText = `${translations[currentLanguage][key]}:`;
                }
            });

            // Translate Help and Share buttons specifically
            const helpButton = document.getElementById('help-button');
            const shareButton = document.getElementById('share-button');
            if (translations[currentLanguage]["Help"]) {
                helpButton.innerText = `‚ùì ${translations[currentLanguage]["Help"]}`;
            }
            if (translations[currentLanguage]["Share"]) {
                shareButton.innerText = `üì§ ${translations[currentLanguage]["Share"]}`;
            }

            // Translate other static texts if necessary
            const mainMenuTitle = document.querySelector('#main-menu h1');
            if (translations[currentLanguage]["Pixel Planet"]) {
                mainMenuTitle.innerText = `üåç ${translations[currentLanguage]["Pixel Planet"]}`;
            }
        }

        function updateDynamicContentLanguage() {
            // Update modals if they are open
            const openModals = document.querySelectorAll('.modal');
            openModals.forEach(modal => {
                const messagePara = modal.querySelector('p');
                if (messagePara && messagePara.dataset.translationKey) {
                    const key = messagePara.dataset.translationKey;
                    messagePara.innerText = translations[currentLanguage][key] || key;
                }

                const buttons = modal.querySelectorAll('button');
                buttons.forEach(button => {
                    const key = button.innerText;
                    if (translations[currentLanguage][key]) {
                        button.innerText = translations[currentLanguage][key];
                    }
                });
            });
        }

        // Load Language on Init
        function loadLanguage() {
            const savedLanguage = localStorage.getItem('PixelPlanetLanguage') || 'en';
            currentLanguage = savedLanguage;
            document.getElementById('language').value = savedLanguage;
            applyTranslations();
        }

        // Function to sanitize inputs
        function sanitizeInput(str) {
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        // Game State
        let resources = {
            water: 0,
            minerals: 0,
            plants: 0,
            energy: 0
        };

        let storage = {
            water: 1000,
            minerals: 500,
            plants: 300,
            energy: 200
        };

        let biomes = [];

        let upgrades = {
            // Existing Upgrades
            waterBoost: {
                name: "üîß Improve Water Collection",
                description: "+10 Water per second",
                baseCost: 100,
                cost: 100,
                effect: (level) => { waterPerSecond = Math.min(waterPerSecond + 10, MAX_RESOURCE_RATE.waterPerSecond); },
                level: 0,
                category: "Resource Boost"
            },
            mineralsBoost: {
                name: "üîß Improve Mineral Extraction",
                description: "+5 Minerals per second",
                baseCost: 200,
                cost: 200,
                effect: (level) => { mineralsPerSecond = Math.min(mineralsPerSecond + 5, MAX_RESOURCE_RATE.mineralsPerSecond); },
                level: 0,
                category: "Resource Boost"
            },
            plantBoost: {
                name: "üîß Enhance Plant Growth",
                description: "+3 Plants per second",
                baseCost: 150,
                cost: 150,
                effect: (level) => { plantsPerSecond = Math.min(plantsPerSecond + 3, MAX_RESOURCE_RATE.plantsPerSecond); },
                level: 0,
                category: "Resource Boost"
            },
            energyBoost: {
                name: "üîß Boost Energy Generation",
                description: "+2 Energy per second",
                baseCost: 120,
                cost: 120,
                effect: (level) => { energyPerSecond = Math.min(energyPerSecond + 2, MAX_RESOURCE_RATE.energyPerSecond); },
                level: 0,
                category: "Resource Boost"
            },
            waterEfficiency: {
                name: "‚öôÔ∏è Water Efficiency",
                description: "Reduce Water consumption by 10%",
                baseCost: 300,
                cost: 300,
                effect: (level) => { 
                    waterConsumption = Math.max(waterConsumption * 0.9, 0.1); 
                },
                level: 0,
                category: "Efficiency Improvement"
            },
            mineralEfficiency: {
                name: "‚öôÔ∏è Mineral Efficiency",
                description: "Reduce Mineral consumption by 10%",
                baseCost: 350,
                cost: 350,
                effect: (level) => { 
                    mineralConsumption = Math.max(mineralConsumption * 0.9, 0.1); 
                },
                level: 0,
                category: "Efficiency Improvement"
            },
            waterStorage: {
                name: "üèóÔ∏è Expand Water Storage",
                description: "Increase Water storage capacity by 500",
                baseCost: 300,
                cost: 300,
                effect: (level) => { storage.water += 500; },
                level: 0,
                category: "Storage Upgrade"
            },
            mineralsStorage: {
                name: "üèóÔ∏è Expand Minerals Storage",
                description: "Increase Minerals storage capacity by 250",
                baseCost: 350,
                cost: 350,
                effect: (level) => { storage.minerals += 250; },
                level: 0,
                category: "Storage Upgrade"
            },
            plantsStorage: {
                name: "üèóÔ∏è Expand Plants Storage",
                description: "Increase Plants storage capacity by 150",
                baseCost: 250,
                cost: 250,
                effect: (level) => { storage.plants += 150; },
                level: 0,
                category: "Storage Upgrade"
            },
            energyStorage: {
                name: "üèóÔ∏è Expand Energy Storage",
                description: "Increase Energy storage capacity by 100",
                baseCost: 200,
                cost: 200,
                effect: (level) => { storage.energy += 100; },
                level: 0,
                category: "Storage Upgrade"
            },
            // New Upgrades
            autoWater: {
                name: "ü§ñ Automate Water Collection",
                description: "Automatically collect 1 Water per second",
                baseCost: 500,
                cost: 500,
                effect: (level) => { waterPerSecond = Math.min(waterPerSecond + 1 * level, MAX_RESOURCE_RATE.waterPerSecond); },
                level: 0,
                category: "Automation"
            },
            autoMinerals: {
                name: "ü§ñ Automate Mineral Extraction",
                description: "Automatically collect 0.5 Minerals per second",
                baseCost: 600,
                cost: 600,
                effect: (level) => { mineralsPerSecond = Math.min(mineralsPerSecond + 0.5 * level, MAX_RESOURCE_RATE.mineralsPerSecond); },
                level: 0,
                category: "Automation"
            },
            autoPlants: {
                name: "ü§ñ Automate Plant Growth",
                description: "Automatically collect 0.3 Plants per second",
                baseCost: 550,
                cost: 550,
                effect: (level) => { plantsPerSecond = Math.min(plantsPerSecond + 0.3 * level, MAX_RESOURCE_RATE.plantsPerSecond); },
                level: 0,
                category: "Automation"
            },
            autoEnergy: {
                name: "ü§ñ Automate Energy Generation",
                description: "Automatically collect 0.2 Energy per second",
                baseCost: 650,
                cost: 650,
                effect: (level) => { energyPerSecond = Math.min(energyPerSecond + 0.2 * level, MAX_RESOURCE_RATE.energyPerSecond); },
                level: 0,
                category: "Automation"
            }
            // Add more upgrades as needed
        };

        let waterPerSecond = 1;
        let mineralsPerSecond = 0;
        let plantsPerSecond = 0;
        let energyPerSecond = 0;

        let waterConsumption = 1; // Example usage
        let mineralConsumption = 1; // Example usage

        let resourceGenerationInterval;
        let autosaveInterval;
        let eventInterval;
        let resourceConsumptionInterval;

        let achievements = {
            firstWater: {
                name: "First Water",
                description: "Collect 100 Water",
                condition: () => resources.water >= 100,
                unlocked: false,
                reward: () => { resources.water = Math.min(resources.water + 50, storage.water, MAX_RESOURCES.water); },
                rewardDescription: "Water +50",
            },
            firstMineral: {
                name: "First Mineral",
                description: "Collect 50 Minerals",
                condition: () => resources.minerals >= 50,
                unlocked: false,
                reward: () => { resources.minerals = Math.min(resources.minerals + 25, storage.minerals, MAX_RESOURCES.minerals); },
                rewardDescription: "Minerals +25",
            },
            reach1000Water: {
                name: "Water Master",
                description: "Collect 1,000 Water",
                condition: () => resources.water >= 1000,
                unlocked: false,
                reward: () => { resources.water = Math.min(resources.water + 200, storage.water, MAX_RESOURCES.water); },
                rewardDescription: "Water +200",
            },
            reach500Minerals: {
                name: "Mineral Tycoon",
                description: "Collect 500 Minerals",
                condition: () => resources.minerals >= 500,
                unlocked: false,
                reward: () => { resources.energy = Math.min(resources.energy + 50, storage.energy, MAX_RESOURCES.energy); },
                rewardDescription: "Energy +50",
            },
            // Add more achievements as needed
        };

        let quests = {
            dailyHarvest: {
                name: "Daily Harvest",
                description: "Collect 50 Plants today",
                condition: () => resources.plants >= 50,
                reward: () => { resources.water = Math.min(resources.water + 100, storage.water, MAX_RESOURCES.water); },
                rewardDescription: "Water +100",
                completed: false,
            },
            mineralMastery: {
                name: "Mineral Mastery",
                description: "Collect 300 Minerals this week",
                condition: () => resources.minerals >= 300,
                reward: () => { resources.energy = Math.min(resources.energy + 50, storage.energy, MAX_RESOURCES.energy); },
                rewardDescription: "Energy +50",
                completed: false,
            },
            weeklyEnergyBoost: {
                name: "Weekly Energy Boost",
                description: "Collect 500 Energy this week",
                condition: () => resources.energy >= 500,
                reward: () => { energyPerSecond = Math.min(energyPerSecond + 5, MAX_RESOURCE_RATE.energyPerSecond); },
                rewardDescription: "Energy Production +5/sec",
                completed: false,
            },
            dailyMineralDrive: {
                name: "Daily Mineral Drive",
                description: "Collect 100 Minerals today",
                condition: () => resources.minerals >= 100,
                reward: () => { mineralsPerSecond = Math.min(mineralsPerSecond + 2, MAX_RESOURCE_RATE.mineralsPerSecond); },
                rewardDescription: "Minerals Production +2/sec",
                completed: false,
            },
            // Add more quests as needed
        };

        let storyMilestones = {
            unlockFirstBiome: {
                condition: () => biomes.length >= 1,
                text: "üåü You've unlocked your first biome! Explore and harness its resources to expand your planet.",
                unlocked: false
            },
            reach500Water: {
                condition: () => resources.water >= 500,
                text: "üíß With ample water, your planet begins to flourish. New possibilities emerge!",
                unlocked: false
            },
            reach1000Energy: {
                condition: () => resources.energy >= 1000,
                text: "‚ö° Energy is abundant! Your planet is now powering advanced technologies.",
                unlocked: false
            },
            // Add more story milestones as needed
        };

        // Maximum Resource Rates
        const MAX_RESOURCE_RATE = {
            waterPerSecond: 100,
            mineralsPerSecond: 50,
            plantsPerSecond: 30,
            energyPerSecond: 20
        };

        // Maximum Resources
        const MAX_RESOURCES = {
            water: 1000000,
            minerals: 500000,
            plants: 300000,
            energy: 200000
        };

        // Events
        const eventTypes = [
            {
                name: "Resource Boom",
                description: "A sudden boom increases your Water and Minerals!",
                effect: () => {
                    safeAddResource('water', 50);
                    safeAddResource('minerals', 25);
                }
            },
            {
                name: "Drought",
                description: "A drought decreases your Water supply!",
                effect: () => {
                    resources.water = Math.max(0, resources.water - 30);
                    updateResourcesUI();
                    checkAchievements();
                    checkQuests();
                }
            },
            {
                name: "Mineral Surge",
                description: "Mineral Surge! You received an extra 40 Minerals!",
                effect: () => {
                    safeAddResource('minerals', 40);
                }
            },
            {
                name: "Plant Overgrowth",
                description: "Plant Overgrowth! You received an extra 20 Plants!",
                effect: () => {
                    safeAddResource('plants', 20);
                }
            },
            {
                name: "Energy Boost",
                description: "Energy Boost! You received an extra 10 Energy!",
                effect: () => {
                    safeAddResource('energy', 10);
                }
            },
            {
                name: "Solar Flare",
                description: "A solar flare disrupts energy generation temporarily.",
                effect: () => {
                    energyPerSecond = Math.max(0, energyPerSecond - 2);
                    showNotification("SolarFlareImpact");
                    setTimeout(() => {
                        energyPerSecond = Math.min(energyPerSecond + 2, MAX_RESOURCE_RATE.energyPerSecond);
                        showNotification("SolarFlareRestored");
                        updateResourcesUI();
                    }, 300000); // Restore after 5 minutes
                }
            },
            {
                name: "Meteor Shower",
                description: "Meteor shower increases mineral collection.",
                effect: () => {
                    mineralsPerSecond = Math.min(mineralsPerSecond + 3, MAX_RESOURCE_RATE.mineralsPerSecond);
                    showNotification("MeteorShowerImpact");
                    setTimeout(() => {
                        mineralsPerSecond = Math.max(mineralsPerSecond - 3, 0);
                        showNotification("MeteorShowerNormalized");
                        updateResourcesUI();
                    }, 300000); // Normalize after 5 minutes
                }
            },
            {
                name: "Alien Encounter",
                description: "Aliens visit your planet, offering advanced technology for free.",
                effect: () => {
                    resources.energy = Math.min(resources.energy + 100, storage.energy, MAX_RESOURCES.energy);
                    showNotification("AlienEncounterReward");
                }
            },
            {
                name: "Resource Plunder",
                description: "Pirates attack your planet, stealing some resources.",
                effect: () => {
                    resources.water = Math.max(0, resources.water - 50);
                    resources.minerals = Math.max(0, resources.minerals - 30);
                    showNotification("ResourcePlundered");
                }
            }
            // Add more unique events as desired
        ];

        // Quests Completion and Reset
        function checkQuests() {
            for (let key in quests) {
                const quest = quests[key];
                if (!quest.completed && quest.condition()) {
                    quest.completed = true;
                    if (quest.reward) quest.reward();
                    showNotification("QuestCompleted", [quest.name, quest.rewardDescription]);
                    generateQuestsUI();
                    trackGAEvent('quest_completed', {
                        'event_category': 'Quest',
                        'event_label': quest.name,
                        'value': quest.rewardDescription
                    });
                    debouncedSaveGame();
                }
            }
        }

        function resetQuests() {
            for (let key in quests) {
                quests[key].completed = false;
            }
            generateQuestsUI();
        }

        // Save Game
        function saveGame() {
            if (isSaving) return;
            isSaving = true;
            try {
                const saveData = {
                    version: "0.6", // Updated version
                    resources,
                    storage,
                    biomes,
                    upgrades,
                    waterPerSecond,
                    mineralsPerSecond,
                    plantsPerSecond,
                    energyPerSecond,
                    achievements,
                    quests,
                    storyMilestones,
                    lastUpdateTime: Date.now()
                };
                localStorage.setItem('PixelPlanetSave_Temp', JSON.stringify(saveData));
                localStorage.setItem('PixelPlanetSave', JSON.stringify(saveData));
                localStorage.removeItem('PixelPlanetSave_Temp');
                showNotification("GameSaved");
            } catch (error) {
                if (error.name === 'QuotaExceededError') {
                    showNotification("SaveLimitExceeded");
                } else {
                    showNotification("SaveError");
                }
                console.error("Error saving game:", error);
            } finally {
                isSaving = false;
            }
        }

        // Debounce Save Function to Prevent Rapid Saves
        function debounce(func, delay) {
            let timeoutId;
            return function(...args) {
                if (timeoutId) clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            }
        }

        const debouncedSaveGame = debounce(saveGame, 500); // 500ms delay
        let isSaving = false;

        // Load from Save Data
        function loadFromSave(gameState) {
            try {
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('game').style.display = 'block';
                resources = gameState.resources;
                storage = gameState.storage;
                biomes = gameState.biomes;
                upgrades = gameState.upgrades;
                waterPerSecond = gameState.waterPerSecond;
                mineralsPerSecond = gameState.mineralsPerSecond;
                plantsPerSecond = gameState.plantsPerSecond;
                energyPerSecond = gameState.energyPerSecond;
                achievements = gameState.achievements;
                quests = gameState.quests;
                storyMilestones = gameState.storyMilestones;
                updateResourcesUI();
                generateUpgradesUI();
                generateAchievementsUI();
                generateQuestsUI();
                displayBiomes();
                handleOfflineResourceGeneration(gameState.lastUpdateTime);
                startResourceGeneration();
                startResourceConsumption();
                startAutosave();
                startEventSystem();
                scheduleQuestReset();
                checkAchievements();
                checkQuests();
                generateStoryUI();
                loadTheme();
                updateSocialSharing();
                showNotification("GameLoaded");
                // Show Continue button only if there is a saved game
                document.getElementById('continue-button').style.display = 'none';
                // Update version number display
                document.getElementById('version').innerText = `Version ${gameState.version}`;
            } catch (error) {
                console.error("Error loading game:", error);
                showNotification("LoadError");
                startNewGame(false);
            }
        }

        // Start New Game
        function startNewGame(confirmStart=true) {
            if (confirmStart && !confirmModal("ConfirmNewGame")) {
                return;
            }
            clearAllIntervals();
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('game').style.display = 'block';
            resources = { water: 0, minerals: 0, plants: 0, energy: 0 };
            storage = { water: 1000, minerals: 500, plants: 300, energy: 200 };
            biomes = [];
            resetUpgrades();
            resetAchievements();
            resetQuests();
            waterPerSecond = 1;
            mineralsPerSecond = 0;
            plantsPerSecond = 0;
            energyPerSecond = 0;
            waterConsumption = 1;
            mineralConsumption = 1;
            updateResourcesUI();
            generateUpgradesUI();
            generateAchievementsUI();
            generateQuestsUI();
            displayBiomes();
            generateStoryUI();
            startResourceGeneration();
            startResourceConsumption();
            startAutosave();
            startEventSystem();
            scheduleQuestReset();
            updateSocialSharing();
            loadTheme();
            showNotification("NewGameStarted");
            debouncedSaveGame();
        }

        // Continue Game
        function continueGame() {
            const savedGame = localStorage.getItem('PixelPlanetSave');
            if (savedGame) {
                const parsedSave = JSON.parse(savedGame);
                loadFromSave(parsedSave);
            } else {
                showNotification("NoSavedGame");
            }
        }

        // Generate Resources Manually
        function generateResources() {
            safeAddResource('water', 10);
            safeAddResource('minerals', 5);
            safeAddResource('plants', 3);
            safeAddResource('energy', 2);
            updateResourcesUI();
            checkAchievements();
            checkQuests();
            showNotification("ResourceGenerated");
            debouncedSaveGame();
        }

        // Safe Add Resource Function
        function safeAddResource(resource, amount) {
            if (!MAX_RESOURCES.hasOwnProperty(resource)) return;
            resources[resource] = Math.min(resources[resource] + amount, storage[resource], MAX_RESOURCES[resource]);
        }

        // Update Resources UI
        function updateResourcesUI() {
            const waterElem = document.getElementById('water');
            const mineralsElem = document.getElementById('minerals');
            const plantsElem = document.getElementById('plants');
            const energyElem = document.getElementById('energy');

            waterElem.innerHTML = `üíß Water: ${formatNumber(resources.water)} / ${formatNumber(storage.water)} (Per Second: <span id="water-rate">${waterPerSecond.toFixed(1)}</span>)`;
            mineralsElem.innerHTML = `‚õè Minerals: ${formatNumber(resources.minerals)} / ${formatNumber(storage.minerals)} (Per Second: <span id="minerals-rate">${mineralsPerSecond.toFixed(1)}</span>)`;
            plantsElem.innerHTML = `üå± Plants: ${formatNumber(resources.plants)} / ${formatNumber(storage.plants)} (Per Second: <span id="plants-rate">${plantsPerSecond.toFixed(1)}</span>)`;
            energyElem.innerHTML = `‚ö° Energy: ${formatNumber(resources.energy)} / ${formatNumber(storage.energy)} (Per Second: <span id="energy-rate">${energyPerSecond.toFixed(1)}</span>)`;

            generateUpgradesUI(); // Update upgrade button states based on new resource counts

            checkStoryMilestones(); // Check for story milestones
        }

        // Generate Upgrades UI
        function generateUpgradesUI() {
            const upgradesDiv = document.getElementById('upgrades');
            upgradesDiv.innerHTML = ''; // Clear existing upgrades

            // Sort upgrades by category
            const categories = {};
            for (let key in upgrades) {
                const upgrade = upgrades[key];
                if (!categories[upgrade.category]) {
                    categories[upgrade.category] = [];
                }
                categories[upgrade.category].push({ key, ...upgrade });
            }

            for (let category in categories) {
                const categoryDiv = document.createElement('div');
                categoryDiv.style.width = '100%';
                categoryDiv.style.textAlign = 'left';
                categoryDiv.style.marginBottom = '10px';
                const categoryTitle = document.createElement('h4');
                categoryTitle.innerText = category;
                categoryDiv.appendChild(categoryTitle);

                // Create a flex container for upgrades to align left to right
                const upgradesRow = document.createElement('div');
                upgradesRow.style.display = 'flex';
                upgradesRow.style.flexWrap = 'wrap';
                upgradesRow.style.gap = '20px';
                upgradesRow.style.justifyContent = 'flex-start';

                categories[category].forEach(upgrade => {
                    // Only display upgrade if affordable or already purchased
                    const isAffordable = resources.water >= upgrade.cost;
                    const upgradeDiv = document.createElement('div');
                    upgradeDiv.className = 'upgrade';

                    const name = document.createElement('span');
                    name.innerText = `${upgrade.name}`;
                    upgradeDiv.appendChild(name);

                    const description = document.createElement('span');
                    description.innerText = `${upgrade.description}`;
                    upgradeDiv.appendChild(description);

                    const cost = document.createElement('span');
                    cost.innerText = `Cost: ${formatNumber(upgrade.cost)} üíß`;
                    upgradeDiv.appendChild(cost);

                    const button = document.createElement('button');
                    button.className = 'upgrade-button';
                    button.innerText = `Buy (Level ${upgrade.level})`;
                    button.disabled = !isAffordable;
                    button.style.backgroundColor = isAffordable ? varCSS('--button-bg-color') : '#888';
                    button.style.cursor = isAffordable ? 'pointer' : 'not-allowed';
                    button.onclick = () => buyUpgrade(upgrade.key);
                    button.setAttribute('aria-label', `Buy upgrade ${upgrade.name}`);

                    // Add tooltip
                    const tooltip = document.createElement('span');
                    tooltip.className = 'tooltip';
                    tooltip.innerText = upgrade.description;
                    button.appendChild(tooltip);

                    upgradeDiv.appendChild(button);

                    upgradesRow.appendChild(upgradeDiv);
                });

                categoryDiv.appendChild(upgradesRow);
                upgradesDiv.appendChild(categoryDiv);
            }
        }

        // Buy Upgrade
        function buyUpgrade(upgradeKey) {
            const upgrade = upgrades[upgradeKey];
            if (!upgrade) return;

            if (resources.water >= upgrade.cost) {
                resources.water -= upgrade.cost;
                upgrade.level += 1;
                upgrade.effect(upgrade.level);
                upgrade.cost = Math.floor(upgrade.baseCost * Math.pow(1.5, upgrade.level));
                updateResourcesUI();
                generateAchievementsUI();
                checkAchievements();
                showNotification("UpgradePurchased", [upgrade.name, `Level ${upgrade.level}`]);
                trackGAEvent('purchase_upgrade', {
                    'event_category': 'Upgrade',
                    'event_label': upgrade.name,
                    'value': upgrade.cost
                });
                debouncedSaveGame();
            } else {
                showNotification("UpgradePurchaseFailed");
            }
        }

        // Reset Upgrades (for new game)
        function resetUpgrades() {
            for (let key in upgrades) {
                upgrades[key].level = 0;
                upgrades[key].cost = upgrades[key].baseCost;
            }
        }

        // Achievements UI
        function generateAchievementsUI() {
            const achievementsDiv = document.getElementById('achievements');
            achievementsDiv.innerHTML = ''; // Clear existing achievements

            for (let key in achievements) {
                const achievement = achievements[key];
                const achievementDiv = document.createElement('div');
                achievementDiv.className = 'achievement';
                if (achievement.unlocked) {
                    achievementDiv.classList.add('unlocked');
                }

                const name = document.createElement('span');
                name.innerText = `${achievement.name}`;
                achievementDiv.appendChild(name);

                const description = document.createElement('span');
                description.innerText = `${achievement.description}`;
                achievementDiv.appendChild(description);

                achievementsDiv.appendChild(achievementDiv);
            }
        }

        // Check and Unlock Achievements
        function checkAchievements() {
            for (let key in achievements) {
                const achievement = achievements[key];
                if (!achievement.unlocked && achievement.condition()) {
                    achievement.unlocked = true;
                    if (achievement.reward) achievement.reward();
                    showNotification("AchievementUnlocked", [achievement.name, achievement.rewardDescription]);
                    generateAchievementsUI();
                    trackGAEvent('achievement_unlocked', {
                        'event_category': 'Achievement',
                        'event_label': achievement.name
                    });
                    debouncedSaveGame();
                }
            }
        }

        // Reset Achievements (for new game)
        function resetAchievements() {
            for (let key in achievements) {
                achievements[key].unlocked = false;
            }
        }

        // Quests UI
        function generateQuestsUI() {
            const questsDiv = document.getElementById('quests');
            questsDiv.innerHTML = ''; // Clear existing quests

            for (let key in quests) {
                const quest = quests[key];
                const questDiv = document.createElement('div');
                questDiv.className = 'quest';
                questDiv.innerHTML = `<strong>${quest.name}:</strong> ${quest.description} - ${quest.completed ? '‚úÖ Completed' : '‚ùå Incomplete'}`;
                questsDiv.appendChild(questDiv);
            }
        }

        // Display Story Milestones
        function generateStoryUI() {
            const storyDiv = document.getElementById('story');
            storyDiv.innerHTML = ''; // Reset story section

            for (let key in storyMilestones) {
                const milestone = storyMilestones[key];
                if (milestone.unlocked) {
                    const paragraph = document.createElement('p');
                    paragraph.innerText = milestone.text;
                    storyDiv.appendChild(paragraph);
                }
            }
        }

        // Check and Unlock Story Milestones
        function checkStoryMilestones() {
            for (let key in storyMilestones) {
                const milestone = storyMilestones[key];
                if (!milestone.unlocked && milestone.condition()) {
                    milestone.unlocked = true;
                    showNotification("StoryMilestone", [milestone.text]);
                    generateStoryUI();
                    trackGAEvent('story_milestone_unlocked', {
                        'event_category': 'Story',
                        'event_label': milestone.text
                    });
                    debouncedSaveGame();
                }
            }
        }

        // Display Biomes
        function displayBiomes() {
            const biomesDiv = document.getElementById('biomes');
            biomesDiv.innerHTML = ''; // Clear existing biomes

            biomes.forEach((biome, index) => {
                const biomeDiv = document.createElement('div');
                biomeDiv.className = 'biome';
                biomeDiv.innerText = `${biome.name} Biome\n${formatBiomeBonuses(biome.bonuses)}`;

                if (index === biomes.length - 1) { // Newly unlocked biome
                    biomeDiv.style.animation = 'highlightBiome 2s ease-in-out';
                }

                biomesDiv.appendChild(biomeDiv);
            });
        }

        // Format Biome Bonuses
        function formatBiomeBonuses(bonuses) {
            let bonusText = '';
            for (let key in bonuses) {
                bonusText += `+${bonuses[key]} ${key.replace('PerSecond', '')} / sec\n`;
            }
            return bonusText;
        }

        // Unlock Terraform (New Biome)
        function unlockTerraform() {
            const terraformBaseCost = 500;
            const terraformCost = terraformBaseCost * (biomes.length + 1);
            if (resources.water >= terraformCost) {
                confirmAction("TerraformConfirm", () => {
                    resources.water -= terraformCost;
                    unlockNewBiome();
                    updateResourcesUI();
                    showNotification("TerraformSuccess");
                    trackGAEvent('terraform_planet', {
                        'event_category': 'Terraform',
                        'event_label': 'Planet terraformed'
                    });
                    debouncedSaveGame();
                });
            } else {
                showNotification("TerraformFailed");
            }
        }

        // Unlock New Biome
        function unlockNewBiome() {
            const newBiome = generateRandomBiome();
            biomes.push(newBiome);
            displayBiomes();
            generateStoryUI();
            checkQuests();
        }

        // Generate Random Biome
        function generateRandomBiome() {
            const biomeNames = ["Forest", "Desert", "Ocean", "Mountain", "Swamp", "Tundra", "Savanna", "Volcano", "Jungle", "Iceberg", "Canyon"];
            let availableBiomes = biomeNames.filter(name => !biomes.some(biome => biome.name === name));

            if (availableBiomes.length === 0) {
                // All biomes unlocked, notify player
                showNotification("AllBiomesUnlocked");
                return { name: "No New Biome", id: biomes.length + 1, bonuses: {} };
            }

            const randomName = availableBiomes[Math.floor(Math.random() * availableBiomes.length)];
            let resourceBonus = {};

            switch(randomName) {
                case "Forest":
                    resourceBonus = { plantsPerSecond: 2 };
                    break;
                case "Desert":
                    resourceBonus = { mineralsPerSecond: 3 };
                    break;
                case "Ocean":
                    resourceBonus = { waterPerSecond: 5 };
                    break;
                case "Mountain":
                    resourceBonus = { mineralsPerSecond: 4 };
                    break;
                case "Swamp":
                    resourceBonus = { plantsPerSecond: 3, waterPerSecond: 2 };
                    break;
                case "Tundra":
                    resourceBonus = { energyPerSecond: 2 };
                    break;
                case "Savanna":
                    resourceBonus = { plantsPerSecond: 2, mineralsPerSecond: 2 };
                    break;
                case "Volcano":
                    resourceBonus = { energyPerSecond: 5 };
                    break;
                case "Jungle":
                    resourceBonus = { plantsPerSecond: 4, waterPerSecond: 3 };
                    break;
                case "Iceberg":
                    resourceBonus = { waterPerSecond: 6 };
                    break;
                case "Canyon":
                    resourceBonus = { mineralsPerSecond: 5 };
                    break;
                default:
                    resourceBonus = {};
            }

            // Apply bonuses with caps
            for (let key in resourceBonus) {
                if (key === "waterPerSecond") {
                    waterPerSecond = Math.min(waterPerSecond + resourceBonus[key], MAX_RESOURCE_RATE.waterPerSecond);
                }
                if (key === "mineralsPerSecond") {
                    mineralsPerSecond = Math.min(mineralsPerSecond + resourceBonus[key], MAX_RESOURCE_RATE.mineralsPerSecond);
                }
                if (key === "plantsPerSecond") {
                    plantsPerSecond = Math.min(plantsPerSecond + resourceBonus[key], MAX_RESOURCE_RATE.plantsPerSecond);
                }
                if (key === "energyPerSecond") {
                    energyPerSecond = Math.min(energyPerSecond + resourceBonus[key], MAX_RESOURCE_RATE.energyPerSecond);
                }
            }

            return { name: randomName, id: biomes.length + 1, bonuses: resourceBonus };
        }

        // Event System
        function startEventSystem() {
            if (eventInterval) clearInterval(eventInterval);
            eventInterval = setInterval(() => {
                triggerRandomEvent();
            }, 600000); // Trigger an event every 10 minutes
        }

        function triggerRandomEvent() {
            if (document.hidden) return; // Prevent triggering when the game is not visible
            const randomEvent = eventTypes[Math.floor(Math.random() * eventTypes.length)];
            randomEvent.effect();
            showNotification("EventTriggered", [randomEvent.name, randomEvent.description]);
            displayEvents(randomEvent);
            updateResourcesUI();
            checkAchievements();
            checkQuests();
            trackGAEvent('event_triggered', {
                'event_category': 'Event',
                'event_label': randomEvent.name
            });
            debouncedSaveGame();
        }

        function displayEvents(event) {
            const eventsDiv = document.getElementById('events');
            const eventDiv = document.createElement('div');
            eventDiv.className = 'event';
            eventDiv.innerText = `${event.name}: ${event.description}`;
            eventsDiv.prepend(eventDiv); // Add to top

            // Limit the number of displayed events to 5
            while (eventsDiv.children.length > 5) {
                eventsDiv.removeChild(eventsDiv.lastChild);
            }
        }

        // Notifications and Modals
        async function openConfirmationModal(messageKey, onConfirm) {
            return new Promise((resolve) => {
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.setAttribute('role', 'dialog');
                modal.setAttribute('aria-modal', 'true');

                const modalContent = document.createElement('div');
                modalContent.className = 'modal-content';

                // Store reference to the element that opened the modal
                const opener = document.activeElement;

                const closeBtn = document.createElement('span');
                closeBtn.className = 'close-modal';
                closeBtn.innerHTML = '&times;';
                closeBtn.onclick = () => { document.body.removeChild(modal); };
                closeBtn.setAttribute('aria-label', 'Close Confirmation Modal');

                const messagePara = document.createElement('p');
                messagePara.innerText = translations[currentLanguage][messageKey] || messageKey;
                messagePara.dataset.translationKey = messageKey;

                const buttonsDiv = document.createElement('div');
                buttonsDiv.style.display = 'flex';
                buttonsDiv.style.justifyContent = 'space-between';
                buttonsDiv.style.marginTop = '20px';

                const confirmBtn = document.createElement('button');
                confirmBtn.innerText = translations[currentLanguage]["Yes"] || "Yes";
                confirmBtn.onclick = () => {
                    onConfirm();
                    document.body.removeChild(modal);
                    opener.focus();
                    resolve(true);
                };
                confirmBtn.setAttribute('aria-label', 'Confirm');

                const cancelBtn = document.createElement('button');
                cancelBtn.innerText = translations[currentLanguage]["No"] || "No";
                cancelBtn.onclick = () => { document.body.removeChild(modal); opener.focus(); resolve(false); };
                cancelBtn.setAttribute('aria-label', 'Cancel');

                buttonsDiv.appendChild(confirmBtn);
                buttonsDiv.appendChild(cancelBtn);

                modalContent.appendChild(closeBtn);
                modalContent.appendChild(messagePara);
                modalContent.appendChild(buttonsDiv);
                modal.appendChild(modalContent);
                document.body.appendChild(modal);

                // Focus management
                confirmBtn.focus();

                // Add event listener for focus trapping
                modal.addEventListener('keydown', function(e) {
                    const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
                    const focusableContent = modal.querySelectorAll(focusableElements);
                    const firstElement = focusableContent[0];
                    const lastElement = focusableContent[focusableContent.length - 1];

                    if (e.key === 'Tab') {
                        if (e.shiftKey) { // Shift + Tab
                            if (document.activeElement === firstElement) {
                                e.preventDefault();
                                lastElement.focus();
                            }
                        } else { // Tab
                            if (document.activeElement === lastElement) {
                                e.preventDefault();
                                firstElement.focus();
                            }
                        }
                    }

                    if (e.key === 'Escape') {
                        e.preventDefault();
                        document.body.removeChild(modal);
                        opener.focus();
                        resolve(false);
                    }
                });
            });
        }

        function confirmModal(messageKey, onConfirm) {
            return openConfirmationModal(messageKey, onConfirm);
        }

        function openAlertModal(messageKey) {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-modal', 'true');

            const modalContent = document.createElement('div');
            modalContent.className = 'modal-content';

            const closeBtn = document.createElement('span');
            closeBtn.className = 'close-modal';
            closeBtn.innerHTML = '&times;';
            closeBtn.onclick = () => { document.body.removeChild(modal); };
            closeBtn.setAttribute('aria-label', 'Close Alert Modal');

            const messagePara = document.createElement('p');
            messagePara.innerText = translations[currentLanguage][messageKey] || messageKey;
            messagePara.dataset.translationKey = messageKey;

            const okBtn = document.createElement('button');
            okBtn.innerText = translations[currentLanguage]["OK"] || "OK";
            okBtn.onclick = () => { document.body.removeChild(modal); };
            okBtn.setAttribute('aria-label', 'OK');

            modalContent.appendChild(closeBtn);
            modalContent.appendChild(messagePara);
            modalContent.appendChild(okBtn);
            modal.appendChild(modalContent);

            document.body.appendChild(modal);

            // Focus management
            okBtn.focus();

            // Add event listener for focus trapping
            modal.addEventListener('keydown', function(e) {
                const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
                const focusableContent = modal.querySelectorAll(focusableElements);
                const firstElement = focusableContent[0];
                const lastElement = focusableContent[focusableContent.length - 1];

                if (e.key === 'Tab') {
                    if (e.shiftKey) { // Shift + Tab
                        if (document.activeElement === firstElement) {
                            e.preventDefault();
                            lastElement.focus();
                        }
                    } else { // Tab
                        if (document.activeElement === lastElement) {
                            e.preventDefault();
                            firstElement.focus();
                        }
                    }
                }

                if (e.key === 'Escape') {
                    e.preventDefault();
                    document.body.removeChild(modal);
                }
            });
        }

        function alertMessage(messageKey) {
            openAlertModal(messageKey);
        }

        // Function to confirm action and get response
        async function confirmAction(messageKey, onConfirm) {
            const confirmed = await confirmModal(messageKey, onConfirm);
            return confirmed;
        }

        // Function to open help modal
        function openHelp() {
            openModal('tutorial-modal');
        }

        // Function to close help modal
        function closeTutorial() {
            closeModal('tutorial-modal');
        }

        // Generic Modal Functions
        function openModal(modalId) {
            closeAllModals();
            const modal = document.getElementById(modalId);
            modal.style.display = 'flex';
            const firstFocusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (firstFocusable) firstFocusable.focus();

            // Add event listener for focus trapping
            modal.addEventListener('keydown', trapTabKey);
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            modal.style.display = 'none';
            modal.removeEventListener('keydown', trapTabKey);
        }

        function closeAllModals() {
            document.querySelectorAll('.modal').forEach(modal => {
                modal.style.display = 'none';
                modal.removeEventListener('keydown', trapTabKey);
            });
        }

        function trapTabKey(e) {
            const modal = e.currentTarget;
            const focusableElements = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
            const focusableContent = modal.querySelectorAll(focusableElements);
            const firstElement = focusableContent[0];
            const lastElement = focusableContent[focusableContent.length - 1];

            if (e.key === 'Tab') {
                if (e.shiftKey) { // Shift + Tab
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else { // Tab
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }

            if (e.key === 'Escape') {
                e.preventDefault();
                closeAllModals();
            }
        }

        // Function to buy upgrades already handled

        // Reset Upgrades already handled

        // Achievements UI and Check already handled

        // Quests UI and Check already handled

        // Story UI and Check already handled

        // Display Biomes already handled

        // Unlock Terraform and New Biome already handled

        // Event System already handled

        // Feedback Modal Handling
        document.getElementById('feedback-form').addEventListener('submit', function(e) {
            e.preventDefault();
            const feedback = sanitizeInput(document.getElementById('feedback').value);
            // Send feedback via email or backend service
            // Example using EmailJS or similar service
            // After successful submission:
            showNotification("FeedbackSubmitted");
            closeModal('feedback-modal');
        });

        // Page Visibility Handling
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                // Pause intervals to save resources
                clearInterval(resourceGenerationInterval);
                clearInterval(resourceConsumptionInterval);
                clearInterval(autosaveInterval);
                clearInterval(eventInterval);
            } else {
                // Calculate offline time and generate resources
                const savedGame = localStorage.getItem('PixelPlanetSave');
                if (savedGame) {
                    const parsedSave = JSON.parse(savedGame);
                    handleOfflineResourceGeneration(parsedSave.lastUpdateTime);
                }
                // Resume intervals
                startResourceGeneration();
                startResourceConsumption();
                startAutosave();
                startEventSystem();
            }
        });

        // Initialize Device Detection
        function detectDevice() {
            const ua = navigator.userAgent;
            if (/Mobi|Android/i.test(ua)) {
                document.body.style.fontSize = '1em';
            } else if (/iPad|Tablet/i.test(ua)) {
                document.body.style.fontSize = '1.1em';
            } else {
                document.body.style.fontSize = '1.2em';
            }
        }

        // Initialize Game
        function initGame() {
            loadLanguage();
            updateSocialSharing();
            detectDevice();

            const savedGame = localStorage.getItem('PixelPlanetSave');
            if (savedGame) {
                const parsedSave = JSON.parse(savedGame);
                if (parsedSave.version !== "0.6") {
                    // Handle version upgrades if necessary
                    showNotification("VersionMismatch");
                    startNewGame(false);
                } else {
                    loadFromSave(parsedSave);
                }
            } else {
                startNewGame();
            }

            // Show Continue button if a saved game exists
            if (savedGame) {
                document.getElementById('continue-button').style.display = 'inline-block';
            }

            // Update version number display
            const savedVersion = localStorage.getItem('PixelPlanetVersion') || '0.6';
            document.getElementById('version').innerText = `Version ${savedVersion}`;
        }

        // Calculate Total Resources
        function calculateTotalResources() {
            return resources.water + resources.minerals + resources.plants + resources.energy;
        }

        // Theme Management
        function toggleTheme() {
            const currentTheme = localStorage.getItem('PixelPlanetTheme') || 'default';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            changeTheme(newTheme);
        }

        function changeTheme(theme) {
            document.body.classList.remove('dark-theme', 'light-theme'); // Remove existing themes
            if (theme === 'dark') {
                document.body.classList.add('dark-theme');
            } else if (theme === 'light') {
                document.body.classList.add('light-theme');
            } else {
                // Default theme settings
                // No class added
            }
            showNotification("ThemeChanged", [capitalizeFirstLetter(theme)]);
            // Save theme selection
            localStorage.setItem('PixelPlanetTheme', theme);
            trackGAEvent('theme_changed', {
                'event_category': 'Theme',
                'event_label': theme
            });
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('PixelPlanetTheme') || 'default';
            changeTheme(savedTheme);
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        // Reset Game
        function resetGame() {
            confirmAction("ConfirmResetGame", () => {
                clearAllIntervals();
                localStorage.removeItem('PixelPlanetSave');
                localStorage.removeItem('PixelPlanetLeaderboard');
                localStorage.removeItem('PixelPlanetVersion');
                localStorage.removeItem('PixelPlanetPlayerName');
                startNewGame(false); // Pass false to avoid double confirmation
                showNotification("GameReset");
                trackGAEvent('game_reset', {
                    'event_category': 'Game',
                    'event_label': 'Game reset by player'
                });
            });
        }

        // Leaderboard and Social Sharing Integration
        // Already handled in updateSocialSharing()

        // Notification Messages and Translations already handled

        // Function to buy upgrades already handled

        // Function to reset upgrades already handled

        // Function to reset achievements already handled

        // Function to reset quests already handled

        // Function to generate biomes already handled

        // Function to handle offline resource generation
        function handleOfflineResourceGeneration(lastSaveTime) {
            const currentTime = Date.now();
            const offlineDuration = Math.floor((currentTime - lastSaveTime) / 1000); // in seconds
            const maxOfflineSeconds = 86400; // 24 hours
            const effectiveDuration = Math.min(offlineDuration, maxOfflineSeconds);
            if (effectiveDuration > 0) {
                safeAddResource('water', effectiveDuration * waterPerSecond);
                safeAddResource('minerals', effectiveDuration * mineralsPerSecond);
                safeAddResource('plants', effectiveDuration * plantsPerSecond);
                safeAddResource('energy', effectiveDuration * energyPerSecond);
                updateResourcesUI();
                showNotification("OfflineResources", [formatNumber(effectiveDuration)]);
                checkAchievements();
                checkQuests();
                trackGAEvent('offline_resources_generated', {
                    'event_category': 'Offline',
                    'event_label': `${formatNumber(effectiveDuration)} seconds`
                });
                debouncedSaveGame();
            }
        }

        // Start Resource Generation
        function startResourceGeneration() {
            if (resourceGenerationInterval) clearInterval(resourceGenerationInterval);
            resourceGenerationInterval = setInterval(() => {
                safeAddResource('water', waterPerSecond);
                safeAddResource('minerals', mineralsPerSecond);
                safeAddResource('plants', plantsPerSecond);
                safeAddResource('energy', energyPerSecond);
                updateResourcesUI();
                checkAchievements();
                checkQuests();
                trackGAEvent('resource_generated', {
                    'event_category': 'Resources',
                    'event_label': 'Auto-generated resources'
                });
                debouncedSaveGame();
            }, 1000);
        }

        // Start Resource Consumption
        function startResourceConsumption() {
            if (resourceConsumptionInterval) clearInterval(resourceConsumptionInterval);
            resourceConsumptionInterval = setInterval(() => {
                consumeResources();
            }, 5000); // Consume resources every 5 seconds
        }

        function consumeResources() {
            resources.water = Math.max(0, resources.water - waterConsumption);
            resources.minerals = Math.max(0, resources.minerals - mineralConsumption);
            updateResourcesUI();
            checkAchievements();
            checkQuests();
            trackGAEvent('resource_consumed', {
                'event_category': 'Resources',
                'event_label': 'Periodic consumption'
            });
            debouncedSaveGame();
        }

        // Start Autosave Functionality
        function startAutosave() {
            if (autosaveInterval) clearInterval(autosaveInterval);
            autosaveInterval = setInterval(() => {
                saveGame();
            }, 30000); // Autosave every 30 seconds
        }

        // Start Event System already handled

        // Schedule Quest Reset (Daily)
        function scheduleQuestReset() {
            const now = new Date();
            const millisTillMidnight = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1, 0,0,0,0) - now;
            setTimeout(function(){
                resetQuests();
                scheduleQuestReset();
            }, millisTillMidnight);
        }

        // Function to reset all temporary effects
        function clearAllTemporaryEffects() {
            waterPerSecond = 1;
            mineralsPerSecond = 0;
            plantsPerSecond = 0;
            energyPerSecond = 0;
            // Reset any other temporary variables or states
        }

        // Function to reset all intervals
        function clearAllIntervals() {
            clearInterval(resourceGenerationInterval);
            clearInterval(resourceConsumptionInterval);
            clearInterval(autosaveInterval);
            clearInterval(eventInterval);
        }

        // Tracking GA Events
        function trackGAEvent(eventName, eventParams) {
            if (typeof gtag === 'function') {
                gtag('event', eventName, eventParams);
            }
        }

        // Initialize Language and Social Sharing
        document.addEventListener("DOMContentLoaded", function() {
            // Language is already loaded in initGame()
            // Show Continue button if a saved game exists
            const savedGame = localStorage.getItem('PixelPlanetSave');
            if (savedGame) {
                document.getElementById('continue-button').style.display = 'inline-block';
            }
        });

        // Accessibility Enhancements are already integrated

        // Start the game on page load
        initGame();
    </script>
</body>
</html>
